# Seguridad en Rails
Apuntes y aclaraciones sobre:

- Cross-Site Request Forgery o CSRF
- Content Security Policy o CSP
- Injections
    - Cross-Site Scripting o XSS
    - SQL Injection
    - etc
- [Esta sección en OWASP sobre Rails](https://cheatsheetseries.owasp.org/cheatsheets/Ruby_on_Rails_Cheat_Sheet.html)
# Cross-Site Request Forgery

Puntos clave:

- Parte de la confianza que las aplicaciones web le dan a las cookies de identificación de sesión las cuales son enviadas entre navegador y servidor.
- Más [detalles en OWASP](https://owasp.org/www-community/attacks/csrf).
- Rails lo combate con `protect_from_forgery` incluído por defecto en `application_controller.rb`.


    protect_from_forgery with: :exception

lo que hace que se incluya el token en todo formulario o petición Ajax generada por Rails.

Por defecto, Rails agrega la cabecera `X-CSRF-TOKEN` en toda petición ajax distinta a GET. Sin dicha cabecera, peticiones distintas a GET no serán aceptadas.

Esto hay que tenerlo en cuenta cuando se usan otras librerías para peticiones tipo Ajax. Para esos casos se puede encontrar el token en la etiqueta meta generada por el helper `<%= csrf_meta_tags %>`.


    <meta name='csrf-token' content='THE-TOKEN'>


- Solo en peticiones POST, PUT, DELETE se pide el token.
- Se previene el robo del token CSFR debido a la política del “mismo origen” que implementan los navegadores. 

Rails usa [tokens de sincronización](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) (tokens aleatorios por criptografia) que están enlazados a la sesión del usuario. Este token se inyecta en cada formulario en el campo oculto `authenticity_token` y es envíado en cada petición POST.

El servidor compara dicho token con el valor asociado a la sesión del usuario. Si falla, impide continuar porque podría ser una petición comprometida.

Del artículo “[Defense Against the Dark Arts: CSRF Attacks](https://dev.to/rtfeldman/defense-against-the-dark-arts-csrf-attacks)”:

> Avoiding this form of CSRF attack is one reason it's important that all our `GET` requests do not result in our server taking any important actions. They should be pretty much read-only, give or take perhaps some logging.

CSRF tokens should be:

- Unique per user session.
- Secret
- Unpredictable (large random value generated by a [secure method](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-cryptographically-secure-pseudo-random-number-generators-csprng)).

Enlaces:

- [Rails Security Guide sobre CSRF](https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf)
- [Understanding Rails' protect_from_forgery](https://blog.nvisium.com/understanding-protectfromforgery)
- [Defense Against the Dark Arts: CSRF Attacks](https://dev.to/rtfeldman/defense-against-the-dark-arts-csrf-attacks)
- [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
- [CSRF en Wikipedia](https://es.wikipedia.org/wiki/Cross-site_request_forgery)
- [Con ejemplos en Rails](https://samuelmullen.com/articles/csrf-protection-and-ruby-on-rails/)


# Ataques de Inyección

Clase de ataques que introducen código o parámetros maliciosos en una aplicación web para que se ejecuten en un contexto de seguridad.


- SQL Injection
- XSS → JavaScript
- CSS Injection
- Textile Injection
- Ajax Injection
- Command Line Injection
- Header Injection

Puntos clave:

- Contexto puede ser: un script, una consulta sql, el lenguaje de programación, la shell de comandos, función de Ruby o Rails
- Prefiere listas permitidas en vez de listas restringidas
    - Podríamos olvidar agregar algo a lista de restricciones. Mejor pensar en qué se permite.

Algunos enlaces:

- [Cross-site scripting en MDN](https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#cross-site_scripting_xss)


## SQL Injection

Apunta acceder a la base de datos o saltar mecanismos de autorización mediante la manipulación de parámetros.


- Los métodos de ActiveRecord tienen filtros para prevenir este tipo de ataques.
- Hay que limpiar los parámetros en casos puntuales como:
    - condicionales de string puro `Project.where("name = '#{params[:name]}'")`
    - al usar `connection.execute()` o `Model.find_by_sql()`

Hay que usar parámetros posicionales en los condicionales en vez de interpolar cadenas. Ejemplo:

    Model.where("zip_code = ? AND quantity >= ?", entered_zip_code, entered_quantity).first

En cualquier parte se puede limpiar cadenas que contengan parámetros con `[sanitize_sql()](https://api.rubyonrails.org/v7.0.4/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_for_conditions)`
[](https://api.rubyonrails.org/v7.0.4/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_for_conditions)
## Cross-Site Scripting o XSS

[Wikipedia](https://es.wikipedia.org/wiki/Cross-site_scripting).
[Strong Parameters Rails 4](https://guides.rubyonrails.org/action_controller_overview.html#strong-parameters).


- El más común y más peligroso
- Inyecta código ejecutable del lado del cliente
- Rails provee métodos para mantenerlos a raya

**Entry Points**

- Es una URL vulnerable y sus parámetros con los cuales un atacante pueden empezar su ataque
- Entry points más comunes son:
    - cualquier parte donde un usuario ingrese datos
    - tableros de mensajes
    - comentarios de usuarios
    - títulos de proyectos, nombres de documentos y resultados de búsquedas también han sido vulnerados

El XSS más común es el HTML/JavaScript Injection al ser JavaScript el lenguaje de lado de cliente más popular. Usos:

- Robo de cookies (Cookie theft): al explotar `document.cookie`
    - Se soluciona con la bandera httpOnly en las cookies.
- Desfiguración (Defacement):
    - el atacante puede presentar información falsa, atraer la víctima para robarle cookies, credenciales u otra información falsa
    - La forma más popular es incluir código de una fuente externa en iframes

**Formas de Prevención**

- Importante filtrar datos de ingreso maliciosos pero también escapar datos de salida a la aplicación web
- Énfasis en trabajar solo con listas de campos permitidos.
    - Listas de restricción nunca estarán completas.

Ejemplo de rails con `strip_tags()`, `strip_links()` y `sanitize()`.

Este código malicioso era limpiado y pasaba el filtro:

    strip_tags("some<<b>script>alert('hello')<</b>/script>")
    
    # devolvía
    # "some<script>alert('hello')</script>"

Usando listas permitidas se resuelve la vulnerabilidad:

    tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
    s = sanitize(user_input, tags: tags, attributes: %w(href title))


## CSS Injection

En el fondo también es una inyección de JavaScript ya que algunos navegadores permiten JS en CSS.

El mejor ejemplo es el [gusano Samy de MySpace](https://samy.pl/myspace/tech.html). La propiedad `moz-binding` también introdujo vulnerabilidades de este tipo.

Para prevenirlo hay que limpiar los datos ingresados por usuarios mediante el método `sanitize()` como una guía para lograrlo. Esto por ejemplo en aplicaciones que permiten al usuario modificar el CSS.


## Textile Injection

(…)

## Ajax Injection

En este caso se aplican los mismos controles que en otros tipos de inyección pero adicionalmente hay que limpiar todas las salidas ya que el ataque se podría ejecutar con la respuesta de la petición/endpoint.

## Command Line Injection

Usa el método `system(command, parameters)` si tu aplicación recibe instrucciones de parte del usuario para ejecutar en el sistema operativo.

## Header Injection

(…)

# Content Security Policy

[Artículo en MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).

Ayuda a prevenir ataques XSS e inyecciones.

Es un header de respuesta del servidor que permite controlar recursos el agente de usuario puede cargar en una determinada página.

Está diseñado para ser retrocompatible. Navegadores que no lo soporten podrían trabajar con servidores con lo implementen y vice versa: ante la ausencia de CSP se usaría la política de mismo origen.

[Rails provee un DSL](https://guides.rubyonrails.org/security.html#content-security-policy-header) para usar estas políticas. Se configura en `config/initializers/content_security_policy.rb`. Esta configuración puede ser sobreescrita en cada controlador según se necesite.


## ¿En qué ayuda?

**Mitigar XSS**: la meta principal de CSP es mitigar y reportar este tipo de ataques. CSP hace posible que los administradores reduzcan los vectores de ataque al especifica los dominios que el navegador debe considerar como fuentes fiables.

Mitigrar sniffing de paquetes: se puede especificar que protocolos son permitidos. Idealmente, solo se debería permitir HTTPS, [cookies con el atributo](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) `[secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)` y haciendo redirecciones automáticas de HTTP a HTTPS.

