# 006 - Update MIPS data to 2025 metrics and send to data Healthmonix

Etiquetas: #luna_help_desk 

Caso EDG-2693.

Reporte:
> In preparation to submit for MIPS.
>
> Currently, this data lives in a MIPS Table and ER Files that updates on a daily basis. Historically, the data was sent via SFTP in an autogenerated matter to files on MIPS Pro

> [!Tip]
> La spreadsheet dice:
> > *Exclude Other, Pelvis & Upper Back Injury Types*

# Componentes Clave

## Tabla settings

### `healthmonix_#{year}_integration_enabled`

> [!Important]
> Controls whether files are uploaded to SFTP.

Hay registros por cada aÃ±o en la tabla `settings` cuya `key` sigue el patrÃ³n `healthmonix_#{year}_integration_enabled` que almacena un booleano. Entonces tenemos:

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_integration_enabled|false|boolean|
|healthmonix_2023_integration_enabled|true|boolean|
|healthmonix_2024_integration_enabled|true|boolean|
|healthmonix_2025_integration_enabled|true|boolean|

> [!Note]
> Para alpha no existe ninguno de estos registros.

### `healthmonix_#{year}_states`

> [!Important]
> Which states to include.

Este es un setting que guarda una lista de estados de USA en forma abreviada. Sigue el mismo patrÃ³n que `healthmonix_#{year}_integration_enabled`.

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_states|CA|list|
|healthmonix_2023_states|AZ,CA,FL,IL,TX,WA|list|
|healthmonix_2024_states|AZ,CA,FL,IL,TX,WA,GA,NY,CO|list|
|healthmonix_2025_states|AZ,CA,FL,IL,TX,WA,GA,NY,CO|list|

> [!Note]
> Para alpha no existe ninguno de estos registros.

### `healthmonix_#{year}_strictly_contained`

> [!Important]
> Controls whether to include only care plans that started AND ended within the year

Lo mismo que los dos anteriores. Este setting guarda un valor booleano. Veamos lo que hay:

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_strictly_contained|true|boolean|
|healthmonix_2023_strictly_contained|false|boolean|
|healthmonix_2024_strictly_contained|false|boolean|
|healthmonix_2025_strictly_contained|false|boolean|


> [!Note]
> Para alpha no existe ninguno de estos registros.

## Workers

Hay un worker principal que dispara los demÃ¡s. El orden que sigue es:

- `Athena::HealthmonixCompleteDataWriterWorker`: hace el trigger de `Athena::HealthmonixYearDataWriterWorker` por cada aÃ±o empezando en 2022
	- Se configura en `periodic_jobs` con cron `CRON_DAILY_AT_2_AM`
- `Athena::HealthmonixYearDataWriterWorker`: hace la generaciÃ³n y export de los datos

Secuencia:
```
Athena::HealthmonixCompleteDataWriterWorker (runs daily at 2:00 AM PT)
		â”œâ”€> Spawns Athena::HealthmonixYearDataWriterWorker for year 2022
		â”œâ”€> Spawns Athena::HealthmonixYearDataWriterWorker for year 2023
		â”œâ”€> Spawns Athena::HealthmonixYearDataWriterWorker for year 2024
		â””â”€> Should spawn for year 2025 (automatic based on current year)
```

## Flujo de los Datos

SegÃºn Claudio:

For each year and state:
1. **Query Database**: Complex SQL query filters appointments based on year, state, injury type, etc.
2. **Merge with Forms Data**: Fetches patient assessment forms from AWS Athena
3. **Generate CSV**: Creates CSV with patient outcomes data
4. **Upload to S3**: Stores in `business-operations/healthmonix/{year}/{state}/{date}/data.csv`
5. **Upload to SFTP (if enabled)**: Uses registration ID and integration key to create filename

> [!Note]
> Para alpha, en S3 hay carpetas de 2023 y 2025 pero dada la falta de registros en `settings` no hay datos relevantes.

## Nombre del archivo en el servidor FTP

Claudio dice:

Format:  `Quality_{registration_id}_{integration_key}_{date_string}.csv`

Ejemplos:
- 2023: Includes date string (e.g., `Quality_17625_egAuLG7aVx_20251001.csv`)
- 2024+: No date string (e.g., `Quality_21742_MlUGF8grFd.csv`)

# Export de los datos ðŸŒŸ

CreÃ­ que iba a necesitar un backfill una vez liberara los cambios porque veÃ­a carpetas tipo `2025-01-23` en S3. Sin embargo, no es asÃ­. **Cada vez que se genera el reporte se cargan todos los datos del aÃ±o**. Por lo cual no necesito hacer un backfill.

La clave es que la fecha que se asigna en cada ejecuciÃ³n corresponde a la carpeta CUANDO se ejecuta el reporte y NO al rango de datos.

SegÃºn Claudio:

> Looking at line 54:
> `date_string = (year == 2022) ? "2022-12-31" : Time.zone.today.iso8601`
>
> The S3 path structure is:
> `business-operations/healthmonix/{year}/{state}/{TODAY's date}/data.csv`
>
> So if the worker runs on January 31st, 2025, it creates:
> `business-operations/healthmonix/2025/CA/2025-01-31/data.csv`

## Ejemplo LÃ­nea de Tiempo del Export

If the worker runs daily throughout 2025:

```
business-operations/healthmonix/2025/CA/
â”œâ”€â”€ 2025-01-01/data.csv  â†’ Contains all 2025 data as of Jan 1
â”œâ”€â”€ 2025-01-02/data.csv  â†’ Contains all 2025 data as of Jan 2
â”œâ”€â”€ 2025-01-31/data.csv  â†’ Contains all 2025 data as of Jan 31
â”œâ”€â”€ 2025-02-28/data.csv  â†’ Contains all 2025 data as of Feb 28
â”œâ”€â”€ 2025-03-31/data.csv  â†’ Contains all 2025 data as of Mar 31
â””â”€â”€ 2025-12-31/data.csv  â†’ Contains all 2025 data (final snapshot)
```

Each file is a **complete export** of all 2025 MIPS data available at that point in time.

# Problema

El problema parece ser solo para el aÃ±o 2025 porque no estÃ¡ el case para este aÃ±o en su lugar.

## Issue 1: Faltan los Registration IDs para 2025

En la funciÃ³n `get_sftp_filename` falta cubrir el aÃ±o 2025:
```ruby
def get_sftp_filename(year, state)
	registration_id, integration_key =
		case year
		when 2022
			case state.postal_abbreviation
			when "CA"
			else
				["UNKNOWN-2022-REGISTRATION-ID", "UNKNOWN-2022-INTEGRATION-KEY"]
			end
		when 2023
			case state.postal_abbreviation
			when "CA"
			when "AZ"
			when "FL"
			when "IL"
			when "TX"
			when "WA"
			else
				["UNKNOWN-2023-REGISTRATION-ID", "UNKNOWN-2023-INTEGRATION-KEY"]
			end
		when 2024
			case state.postal_abbreviation
			when "CA"
			when "AZ"
			when "FL"
			when "IL"
			when "TX"
			when "WA"
			when "GA"
			when "NY"
			when "CO"
			else
				["UNKNOWN-2023-REGISTRATION-ID", "UNKNOWN-2023-INTEGRATION-KEY"]
			end
		else
			["UNKNOWN-#{year}-REGISTRATION-ID", "UNKNOWN-#{year}-INTEGRATION-KEY"]
		end

	date_string = (Time.zone.today.iso8601.gsub("-", "") if year == 2023)

	"#{['Quality', registration_id, integration_key, date_string].compact.join('_')}.csv"
end
```

### SoluciÃ³n: Dar soporte al aÃ±o 2025 y copiar los registration IDs ðŸŸ¢

Los valores estÃ¡n en la spreadsheet que se compartiÃ³ en el reporte. Hay que agregar al case los nueve estados que se identifican en la 1era hoja y hacer el emparejamiento con sus respectivos registration_id e integration_key.

## Issue 2: ActualizaciÃ³n de cÃ³digo MSK11 al MSK15

En el commit de la actualizaciÃ³n de 2024 Ryan hizo este cambio:
```ruby
if functional_treatment.present?
	nprs_treatment =
		functional_treatment
		# code
		.gsub("MSK02", "MSK12")
		.gsub("MSK01", "MSK11")
		.gsub("MSK03", "MSK13")
		.gsub("MSK04", "MSK14")
		.gsub("MSK05", "MSK15")

	result_nprs["Treatment"] = nprs_treatment
end
```

Ahora para 2025 se pide:
> To note, MSK11-15 changed, which was noted in the "Visit Table-Column" tab and "Mapping Logic 2025" tab.

Cuando veo la hoja de cÃ¡lculo en la tab "Visit Table-Column" dice
> New Mapping table-No longer any measures with MSK11, MSK 12, MSK13, MSK 14, MSK15

Y cuando reviso en "Mapping Logic 2025" encuentro que hay que actualizar a lo siguiente:

| Pro Mapping      | Pro Mapping Update |
|------------------|--------------------|
| MSK11            | MSK06              |
| MSK12            | MSK07              |
| MSK13            | MSK08              |
| MSK14            | MSK09              |
| MSK14            | MSK09              |
| MSK14            | MSK09              |
| MSK15            | MSK10              |
| MSK15            | MSK10              |

### SoluciÃ³n: Dar soporte para 2025 sin afectar aÃ±os anteriores ðŸŸ¢

El fix que Claudio sugiriÃ³ fue dar soporte a estos nuevos cÃ³digos solo para 2025. Entonces el cambio fue pasar el parÃ¡metro `year` a las funciones correspondientes y luego usarlo para hacer el `gsub`. Si el aÃ±o es 2025, se aplican los nuevos cÃ³digos. Sino se deja como estaba.

> [!Important]
> En el fix el `gsub` se hace en base al cÃ³digo MSK01-05. Esto es porque son los cÃ³digos que devuelve la funciÃ³n `query`. Haciendo el `gsub` es la forma en que se hace la modificaciÃ³n sin alterar el resultado de la consulta.
>
> La `query` tiene esta parte desde donde se origina los cÃ³digos MSK:
> ```sql
> injury_extended
>	AS (
>		SELECT id
>			,UPPER(body_part_type) AS body_part
>			,(
>				CASE
>					-- otros statements
>					WHEN inj.body_part_type = 'shoulder_arm' AND #{year} >= 2024
>						THEN 'MSK02'
>					WHEN inj.body_part_type = 'neck' AND #{year} >= 2024
>						THEN 'MSK01'
>					WHEN inj.body_part_type = 'lower_back' AND #{year} >= 2024
>						THEN 'MSK03'
>					WHEN inj.body_part_type = 'hip' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'hip_joint_replacement' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'foot_and_ankle' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'knee' AND #{year} >= 2024
>						THEN 'MSK05'
>					WHEN inj.body_part_type = 'knee_joint_replacement' AND #{year} >= 2024
>						THEN 'MSK05'
>```
>
> Esos los dejo quietos para no alterar los demÃ¡s exports.

## Issue 3: No hay datos de 2025 para CO, TX, GA

Reportaron que para 2025 no salÃ­an datos para esos tres estados. Lo cual fue raro porque en S3 se podÃ­a ver que todos tenÃ­an exports.

### SoluciÃ³n: Healhtmonix tenÃ­a que revisar la configuraciÃ³n SFTP ðŸŸ¢

PedÃ­ que preguntaran si podÃ­an verificar. AsÃ­ hicieron y eso fue el problema.

# Mapa de EjecuciÃ³n General â„¹ï¸

Dado al tamaÃ±o de las funciones me cuesta un poco entender cÃ³mo todas se relacionan entre sÃ­. Le pedÃ­ a Claudio generar un diagrama de secuencia de Mermaid. TambiÃ©n generÃ³ un esquema sencillo de cÃ³mo se relacionan las funciones de este worker.

## Cadena de ejecuciÃ³n de las funciones

```
perform(year)
â”œâ”€â”€ get_states(year)
â””â”€â”€ [for each state]
	â”œâ”€â”€ write_data_to_s3(year, state)
	â”‚   â”œâ”€â”€ create_dataset(year, state)
	â”‚   â”‚   â”œâ”€â”€ query(year, state) â†’ DB
	â”‚   â”‚   â””â”€â”€ process_queue(queue, year)
	â”‚   â”‚       â”œâ”€â”€ care_plan_completed_forms_data(ids) â†’ Athena
	â”‚   â”‚       â””â”€â”€ merge_appointments_data_with_outcomes_data(appts, forms, year)
	â”‚   â””â”€â”€ s3_object.upload_stream(CSV)
	â””â”€â”€ [if enabled]
			â”œâ”€â”€ read_csv_tempfile(year, state)
			â”œâ”€â”€ get_sftp_filename(year, state)
			â””â”€â”€ upload_to_ftp_server(filename, file)
```

## Secuencia Completa

```
sequenceDiagram
      participant Scheduler as Sidekiq Scheduler
      participant Worker as HealthmonixYearDataWriterWorker
      participant Redis as RedlockService
      participant Settings as Setting Model
      participant DB as PostgreSQL
      participant Athena as AWS Athena
      participant S3 as AWS S3
      participant SFTP as Healthmonix SFTP

      Scheduler->>Worker: perform(year)
      Worker->>Redis: lock("healthmonix_year_data_writer_lock")
      Redis-->>Worker: lock acquired

      Worker->>Settings: load_safe("healthmonix_#{year}_integration_enabled")
      Settings-->>Worker: boolean (enabled/disabled)

      Worker->>Worker: get_states(year)
      Worker->>Settings: load_safe("healthmonix_#{year}_states")
      Settings-->>Worker: ["CA", "AZ", "FL", ...]
      Worker->>DB: State.includes(:regions).where(...)
      DB-->>Worker: Array of State objects

      loop For each state
          Worker->>Worker: write_data_to_s3(year, state)
          Worker->>Worker: create_dataset(year, state)
          Worker->>DB: query(year, state) - Complex SQL
          DB-->>Worker: appointment_data (raw rows)

          loop Buffer appointments by care_plan_id
              alt Buffer full (500 care plans)
                  Worker->>Worker: process_queue(queue, year)
                  Worker->>Worker: care_plan_completed_forms_data(care_plan_ids)
                  Worker->>Athena: run(SELECT * FROM patient_forms_mips...)
                  Athena-->>Worker: form summaries with scores

                  loop For each care plan
                      Worker->>Worker: merge_appointments_data_with_outcomes_data(appointments, forms, year)

                      loop For each appointment
                          Note over Worker: Create result_functional row
                          Note over Worker: Create result_nprs row
                          alt year >= 2025
                              Note over Worker: Map MSK01-05 â†’ MSK06-10
                          else year < 2025
                              Note over Worker: Map MSK01-05 â†’ MSK11-15
                          end
                          Note over Worker: Create result_length_of_stay row
                          Note over Worker: Match with form scores
                      end

                      Worker-->>Worker: processed appointment rows
                  end

                  Worker-->>Worker: processed_result
              end
          end

          Worker->>S3: upload_stream(CSV data)
          S3-->>Worker: upload complete

          alt SFTP enabled for year
              Worker->>Worker: read_csv_tempfile(year, state)
              Worker->>S3: download CSV
              S3-->>Worker: tempfile
              Worker->>Worker: get_sftp_filename(year, state)
              Note over Worker: Generate filename with<br/>registration_id + integration_key
              Worker->>SFTP: upload!(tempfile, destination)
              SFTP-->>Worker: upload complete
          end
      end

      Worker-->>Scheduler: job complete
```

![[006.sequence.full.png]]

## Secuencia Resumida

CÃ³digo del diagrama:
```
sequenceDiagram
		participant Worker as HealthmonixYearDataWriterWorker
		participant DB as PostgreSQL
		participant Athena as AWS Athena
		participant S3 as AWS S3
		participant SFTP as SFTP Server

		Worker->>Worker: perform(year)
		Worker->>Worker: get_states(year)

		loop For each state
				Worker->>Worker: write_data_to_s3(year, state)
				Worker->>Worker: create_dataset(year, state)
				Worker->>DB: query(year, state)
				DB-->>Worker: appointment_data

				loop Process batches of 500
						Worker->>Worker: process_queue(queue, year)
						Worker->>Worker: care_plan_completed_forms_data(ids)
						Worker->>Athena: run(SELECT FROM patient_forms_mips)
						Athena-->>Worker: form_data

						Worker->>Worker: merge_appointments_data_with_outcomes_data(appts, forms, year)
						Note over Worker: Apply year-conditional<br/>MSK mapping
						Worker-->>Worker: processed_rows
				end

				Worker->>S3: upload_stream(CSV)

				opt SFTP enabled
						Worker->>Worker: read_csv_tempfile(year, state)
						Worker->>Worker: get_sftp_filename(year, state)
						Worker->>SFTP: upload!(file)
				end
		end
```

![[006.sequence.concise.png]]