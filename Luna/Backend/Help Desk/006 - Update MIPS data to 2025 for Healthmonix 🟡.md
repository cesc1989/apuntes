# 006 - Update MIPS data to 2025 metrics and send to data Healthmonix

Etiquetas: #luna_help_desk 

Caso EDG-2693.

Reporte:
> In preparation to submit for MIPS.
>
> Currently, this data lives in a MIPS Table and ER Files that updates on a daily basis. Historically, the data was sent via SFTP in an autogenerated matter to files on MIPS Pro

> [!Tip]
> La spreadsheet dice:
> > *Exclude Other, Pelvis & Upper Back Injury Types*

# Componentes Clave

## Tabla settings

### `healthmonix_#{year}_integration_enabled`

> [!Important]
> Controls whether files are uploaded to SFTP.

Hay registros por cada a√±o en la tabla `settings` cuya `key` sigue el patr√≥n `healthmonix_#{year}_integration_enabled` que almacena un booleano. Entonces tenemos:

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_integration_enabled|false|boolean|
|healthmonix_2023_integration_enabled|true|boolean|
|healthmonix_2024_integration_enabled|true|boolean|
|healthmonix_2025_integration_enabled|true|boolean|

> [!Note]
> Para alpha no existe ninguno de estos registros.

### `healthmonix_#{year}_states`

> [!Important]
> Which states to include.

Este es un setting que guarda una lista de estados de USA en forma abreviada. Sigue el mismo patr√≥n que `healthmonix_#{year}_integration_enabled`.

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_states|CA|list|
|healthmonix_2023_states|AZ,CA,FL,IL,TX,WA|list|
|healthmonix_2024_states|AZ,CA,FL,IL,TX,WA,GA,NY,CO|list|
|healthmonix_2025_states|AZ,CA,FL,IL,TX,WA,GA,NY,CO|list|

> [!Note]
> Para alpha no existe ninguno de estos registros.

### `healthmonix_#{year}_strictly_contained`

> [!Important]
> Controls whether to include only care plans that started AND ended within the year

Lo mismo que los dos anteriores. Este setting guarda un valor booleano. Veamos lo que hay:

|key|value|setting_type|
|---|-----|------------|
|healthmonix_2022_strictly_contained|true|boolean|
|healthmonix_2023_strictly_contained|false|boolean|
|healthmonix_2024_strictly_contained|false|boolean|
|healthmonix_2025_strictly_contained|false|boolean|


> [!Note]
> Para alpha no existe ninguno de estos registros.

## Workers

Hay un worker principal que dispara los dem√°s. El orden que sigue es:

- `Athena::HealthmonixCompleteDataWriterWorker`: hace el trigger de `Athena::HealthmonixYearDataWriterWorker` por cada a√±o empezando en 2022
	- Se configura en `periodic_jobs` con cron `CRON_DAILY_AT_2_AM`
- `Athena::HealthmonixYearDataWriterWorker`: hace la generaci√≥n y export de los datos

Secuencia:
```
Athena::HealthmonixCompleteDataWriterWorker (runs daily at 2:00 AM PT)
		‚îú‚îÄ> Spawns Athena::HealthmonixYearDataWriterWorker for year 2022
		‚îú‚îÄ> Spawns Athena::HealthmonixYearDataWriterWorker for year 2023
		‚îú‚îÄ> Spawns Athena::HealthmonixYearDataWriterWorker for year 2024
		‚îî‚îÄ> Should spawn for year 2025 (automatic based on current year)
```

## Flujo de los Datos

Seg√∫n Claudio:

For each year and state:
1. **Query Database**: Complex SQL query filters appointments based on year, state, injury type, etc.
2. **Merge with Forms Data**: Fetches patient assessment forms from AWS Athena
3. **Generate CSV**: Creates CSV with patient outcomes data
4. **Upload to S3**: Stores in `business-operations/healthmonix/{year}/{state}/{date}/data.csv`
5. **Upload to SFTP (if enabled)**: Uses registration ID and integration key to create filename

> [!Note]
> Para alpha, en S3 hay carpetas de 2023 y 2025 pero dada la falta de registros en `settings` no hay datos relevantes.

## Nombre del archivo en el servidor FTP

Claudio dice:

Format:  `Quality_{registration_id}_{integration_key}_{date_string}.csv`

Ejemplos:
- 2023: Includes date string (e.g., `Quality_17625_egAuLG7aVx_20251001.csv`)
- 2024+: No date string (e.g., `Quality_21742_MlUGF8grFd.csv`)

# Export de los datos üåü

Cre√≠ que iba a necesitar un backfill una vez liberara los cambios porque ve√≠a carpetas tipo `2025-01-23` en S3. Sin embargo, no es as√≠. **Cada vez que se genera el reporte se cargan todos los datos del a√±o**. Por lo cual no necesito hacer un backfill.

La clave es que la fecha que se asigna en cada ejecuci√≥n corresponde a la carpeta CUANDO se ejecuta el reporte y NO al rango de datos.

Seg√∫n Claudio:

> Looking at line 54:
> `date_string = (year == 2022) ? "2022-12-31" : Time.zone.today.iso8601`
>
> The S3 path structure is:
> `business-operations/healthmonix/{year}/{state}/{TODAY's date}/data.csv`
>
> So if the worker runs on January 31st, 2025, it creates:
> `business-operations/healthmonix/2025/CA/2025-01-31/data.csv`

## Ejemplo L√≠nea de Tiempo del Export

If the worker runs daily throughout 2025:

```
business-operations/healthmonix/2025/CA/
‚îú‚îÄ‚îÄ 2025-01-01/data.csv  ‚Üí Contains all 2025 data as of Jan 1
‚îú‚îÄ‚îÄ 2025-01-02/data.csv  ‚Üí Contains all 2025 data as of Jan 2
‚îú‚îÄ‚îÄ 2025-01-31/data.csv  ‚Üí Contains all 2025 data as of Jan 31
‚îú‚îÄ‚îÄ 2025-02-28/data.csv  ‚Üí Contains all 2025 data as of Feb 28
‚îú‚îÄ‚îÄ 2025-03-31/data.csv  ‚Üí Contains all 2025 data as of Mar 31
‚îî‚îÄ‚îÄ 2025-12-31/data.csv  ‚Üí Contains all 2025 data (final snapshot)
```

Each file is a **complete export** of all 2025 MIPS data available at that point in time.

# Problema

El problema parece ser solo para el a√±o 2025 porque no est√° el case para este a√±o en su lugar.

## Issue 1: Faltan los Registration IDs para 2025

En la funci√≥n `get_sftp_filename` falta cubrir el a√±o 2025:
```ruby
def get_sftp_filename(year, state)
	registration_id, integration_key =
		case year
		when 2022
			case state.postal_abbreviation
			when "CA"
			else
				["UNKNOWN-2022-REGISTRATION-ID", "UNKNOWN-2022-INTEGRATION-KEY"]
			end
		when 2023
			case state.postal_abbreviation
			when "CA"
			when "AZ"
			when "FL"
			when "IL"
			when "TX"
			when "WA"
			else
				["UNKNOWN-2023-REGISTRATION-ID", "UNKNOWN-2023-INTEGRATION-KEY"]
			end
		when 2024
			case state.postal_abbreviation
			when "CA"
			when "AZ"
			when "FL"
			when "IL"
			when "TX"
			when "WA"
			when "GA"
			when "NY"
			when "CO"
			else
				["UNKNOWN-2023-REGISTRATION-ID", "UNKNOWN-2023-INTEGRATION-KEY"]
			end
		else
			["UNKNOWN-#{year}-REGISTRATION-ID", "UNKNOWN-#{year}-INTEGRATION-KEY"]
		end

	date_string = (Time.zone.today.iso8601.gsub("-", "") if year == 2023)

	"#{['Quality', registration_id, integration_key, date_string].compact.join('_')}.csv"
end
```

### Soluci√≥n: Dar soporte al a√±o 2025 y copiar los registration IDs üü¢

Los valores est√°n en la spreadsheet que se comparti√≥ en el reporte. Hay que agregar al case los nueve estados que se identifican en la 1era hoja y hacer el emparejamiento con sus respectivos registration_id e integration_key.

## Issue 2: Actualizaci√≥n de c√≥digo MSK11 al MSK15

En el commit de la actualizaci√≥n de 2024 Ryan hizo este cambio:
```ruby
if functional_treatment.present?
	nprs_treatment =
		functional_treatment
		# code
		.gsub("MSK02", "MSK12")
		.gsub("MSK01", "MSK11")
		.gsub("MSK03", "MSK13")
		.gsub("MSK04", "MSK14")
		.gsub("MSK05", "MSK15")

	result_nprs["Treatment"] = nprs_treatment
end
```

Ahora para 2025 se pide:
> To note, MSK11-15 changed, which was noted in the "Visit Table-Column" tab and "Mapping Logic 2025" tab.

Cuando veo la hoja de c√°lculo en la tab "Visit Table-Column" dice
> New Mapping table-No longer any measures with MSK11, MSK 12, MSK13, MSK 14, MSK15

Y cuando reviso en "Mapping Logic 2025" encuentro que hay que actualizar a lo siguiente:

| Pro Mapping      | Pro Mapping Update |
|------------------|--------------------|
| MSK11            | MSK06              |
| MSK12            | MSK07              |
| MSK13            | MSK08              |
| MSK14            | MSK09              |
| MSK14            | MSK09              |
| MSK14            | MSK09              |
| MSK15            | MSK10              |
| MSK15            | MSK10              |

### Soluci√≥n: Dar soporte para 2025 sin afectar a√±os anteriores üü¢

El fix que Claudio sugiri√≥ fue dar soporte a estos nuevos c√≥digos solo para 2025. Entonces el cambio fue pasar el par√°metro `year` a las funciones correspondientes y luego usarlo para hacer el `gsub`. Si el a√±o es 2025, se aplican los nuevos c√≥digos. Sino se deja como estaba.

> [!Important]
> En el fix el `gsub` se hace en base al c√≥digo MSK01-05. Esto es porque son los c√≥digos que devuelve la funci√≥n `query`. Haciendo el `gsub` es la forma en que se hace la modificaci√≥n sin alterar el resultado de la consulta.
>
> La `query` tiene esta parte desde donde se origina los c√≥digos MSK:
> ```sql
> injury_extended
>	AS (
>		SELECT id
>			,UPPER(body_part_type) AS body_part
>			,(
>				CASE
>					-- otros statements
>					WHEN inj.body_part_type = 'shoulder_arm' AND #{year} >= 2024
>						THEN 'MSK02'
>					WHEN inj.body_part_type = 'neck' AND #{year} >= 2024
>						THEN 'MSK01'
>					WHEN inj.body_part_type = 'lower_back' AND #{year} >= 2024
>						THEN 'MSK03'
>					WHEN inj.body_part_type = 'hip' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'hip_joint_replacement' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'foot_and_ankle' AND #{year} >= 2024
>						THEN 'MSK04'
>					WHEN inj.body_part_type = 'knee' AND #{year} >= 2024
>						THEN 'MSK05'
>					WHEN inj.body_part_type = 'knee_joint_replacement' AND #{year} >= 2024
>						THEN 'MSK05'
>```
>
> Esos los dejo quietos para no alterar los dem√°s exports.

## Issue 3: No hay datos de 2025 para CO, TX, GA

Reportaron que para 2025 no sal√≠an datos para esos tres estados. Lo cual fue raro porque en S3 se pod√≠a ver que todos ten√≠an exports.

### Soluci√≥n: Healhtmonix ten√≠a que revisar la configuraci√≥n SFTP üü¢

Ped√≠ que preguntaran si pod√≠an verificar. As√≠ hicieron y eso fue el problema.

# Mapa de Ejecuci√≥n General ‚ÑπÔ∏è

Dado al tama√±o de las funciones me cuesta un poco entender c√≥mo todas se relacionan entre s√≠. Le ped√≠ a Claudio generar un diagrama de secuencia de Mermaid. Tambi√©n gener√≥ un esquema sencillo de c√≥mo se relacionan las funciones de este worker.

## Cadena de ejecuci√≥n de las funciones

```
perform(year)
‚îú‚îÄ‚îÄ get_states(year)
‚îî‚îÄ‚îÄ [for each state]
	‚îú‚îÄ‚îÄ write_data_to_s3(year, state)
	‚îÇ   ‚îú‚îÄ‚îÄ create_dataset(year, state)
	‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ query(year, state) ‚Üí DB
	‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ process_queue(queue, year)
	‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ care_plan_completed_forms_data(ids) ‚Üí Athena
	‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ merge_appointments_data_with_outcomes_data(appts, forms, year)
	‚îÇ   ‚îî‚îÄ‚îÄ s3_object.upload_stream(CSV)
	‚îî‚îÄ‚îÄ [if enabled]
			‚îú‚îÄ‚îÄ read_csv_tempfile(year, state)
			‚îú‚îÄ‚îÄ get_sftp_filename(year, state)
			‚îî‚îÄ‚îÄ upload_to_ftp_server(filename, file)
```

## Secuencia Completa

```
sequenceDiagram
      participant Scheduler as Sidekiq Scheduler
      participant Worker as HealthmonixYearDataWriterWorker
      participant Redis as RedlockService
      participant Settings as Setting Model
      participant DB as PostgreSQL
      participant Athena as AWS Athena
      participant S3 as AWS S3
      participant SFTP as Healthmonix SFTP

      Scheduler->>Worker: perform(year)
      Worker->>Redis: lock("healthmonix_year_data_writer_lock")
      Redis-->>Worker: lock acquired

      Worker->>Settings: load_safe("healthmonix_#{year}_integration_enabled")
      Settings-->>Worker: boolean (enabled/disabled)

      Worker->>Worker: get_states(year)
      Worker->>Settings: load_safe("healthmonix_#{year}_states")
      Settings-->>Worker: ["CA", "AZ", "FL", ...]
      Worker->>DB: State.includes(:regions).where(...)
      DB-->>Worker: Array of State objects

      loop For each state
          Worker->>Worker: write_data_to_s3(year, state)
          Worker->>Worker: create_dataset(year, state)
          Worker->>DB: query(year, state) - Complex SQL
          DB-->>Worker: appointment_data (raw rows)

          loop Buffer appointments by care_plan_id
              alt Buffer full (500 care plans)
                  Worker->>Worker: process_queue(queue, year)
                  Worker->>Worker: care_plan_completed_forms_data(care_plan_ids)
                  Worker->>Athena: run(SELECT * FROM patient_forms_mips...)
                  Athena-->>Worker: form summaries with scores

                  loop For each care plan
                      Worker->>Worker: merge_appointments_data_with_outcomes_data(appointments, forms, year)

                      loop For each appointment
                          Note over Worker: Create result_functional row
                          Note over Worker: Create result_nprs row
                          alt year >= 2025
                              Note over Worker: Map MSK01-05 ‚Üí MSK06-10
                          else year < 2025
                              Note over Worker: Map MSK01-05 ‚Üí MSK11-15
                          end
                          Note over Worker: Create result_length_of_stay row
                          Note over Worker: Match with form scores
                      end

                      Worker-->>Worker: processed appointment rows
                  end

                  Worker-->>Worker: processed_result
              end
          end

          Worker->>S3: upload_stream(CSV data)
          S3-->>Worker: upload complete

          alt SFTP enabled for year
              Worker->>Worker: read_csv_tempfile(year, state)
              Worker->>S3: download CSV
              S3-->>Worker: tempfile
              Worker->>Worker: get_sftp_filename(year, state)
              Note over Worker: Generate filename with<br/>registration_id + integration_key
              Worker->>SFTP: upload!(tempfile, destination)
              SFTP-->>Worker: upload complete
          end
      end

      Worker-->>Scheduler: job complete
```

![[006.sequence.full.png]]

## Secuencia Resumida

C√≥digo del diagrama:
```
sequenceDiagram
		participant Worker as HealthmonixYearDataWriterWorker
		participant DB as PostgreSQL
		participant Athena as AWS Athena
		participant S3 as AWS S3
		participant SFTP as SFTP Server

		Worker->>Worker: perform(year)
		Worker->>Worker: get_states(year)

		loop For each state
				Worker->>Worker: write_data_to_s3(year, state)
				Worker->>Worker: create_dataset(year, state)
				Worker->>DB: query(year, state)
				DB-->>Worker: appointment_data

				loop Process batches of 500
						Worker->>Worker: process_queue(queue, year)
						Worker->>Worker: care_plan_completed_forms_data(ids)
						Worker->>Athena: run(SELECT FROM patient_forms_mips)
						Athena-->>Worker: form_data

						Worker->>Worker: merge_appointments_data_with_outcomes_data(appts, forms, year)
						Note over Worker: Apply year-conditional<br/>MSK mapping
						Worker-->>Worker: processed_rows
				end

				Worker->>S3: upload_stream(CSV)

				opt SFTP enabled
						Worker->>Worker: read_csv_tempfile(year, state)
						Worker->>Worker: get_sftp_filename(year, state)
						Worker->>SFTP: upload!(file)
				end
		end
```

![[006.sequence.concise.png]]